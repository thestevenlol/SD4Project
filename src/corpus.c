// filepath: src/corpus.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <dirent.h>
#include <time.h>
#include <errno.h>
#include <limits.h>

#include "../headers/corpus.h"
#include "../headers/uthash.h" // Assuming this is still used
#include "../headers/coverage.h" // For COVERAGE_MAP_SIZE, coverage_t

// Hash table entry for uthash
typedef struct {
    int input_value;           // key
    CorpusEntry* entry;        // value
    UT_hash_handle hh;         // makes this structure hashable
} CorpusHash;

// Global corpus variables
static CorpusHash* corpus_table = NULL;
static int corpus_size = 0;
static char corpus_directory[1024] = {0};

// Initialize corpus directory
int initializeCorpus(const char* corpus_dir) {
    // Clean up any previous in-memory corpus state
    cleanupCorpus();

    // Store corpus directory path
    strncpy(corpus_directory, corpus_dir, sizeof(corpus_directory) - 1);
    corpus_directory[sizeof(corpus_directory) - 1] = '\0'; // Ensure null termination

    // Create directory if it doesn't exist
    struct stat st = {0};
    if (stat(corpus_directory, &st) == -1) {
        if (mkdir(corpus_directory, 0755) == -1 && errno != EEXIST) { // Use 0755 for permissions
            perror("Failed to create corpus directory");
            fprintf(stderr, "Directory path: %s\n", corpus_directory);
            return -1;
        }
         printf("Corpus directory created: %s\n", corpus_directory);
    } else {
         printf("Using existing corpus directory: %s\n", corpus_directory);
    }


    return 0;
}

// Save an input to the corpus (in memory and to file)
// coverage_map: Pointer to the coverage map generated by this input (e.g., from shared memory)
int saveToCorpus(int input_value, const coverage_t* coverage_map, double fitness_score, int is_interesting) {
    CorpusHash* hash_entry;

    // Check if input already exists in the in-memory corpus
    HASH_FIND_INT(corpus_table, &input_value, hash_entry);

    if (hash_entry) {
        // Update existing entry if this one is "better" (e.g., higher fitness)
        // Or if it's newly marked as interesting (e.g., caused a crash)
        if (is_interesting || fitness_score > hash_entry->entry->fitness_score) {
            hash_entry->entry->fitness_score = fitness_score;
            // Update coverage map if provided and different? Or just keep the best one?
            if (coverage_map && hash_entry->entry->coverage_map) {
                 memcpy(hash_entry->entry->coverage_map, coverage_map, COVERAGE_MAP_SIZE * sizeof(coverage_t));
            }
            hash_entry->entry->is_interesting = hash_entry->entry->is_interesting || is_interesting; // Keep interesting flag if set
            hash_entry->entry->timestamp = time(NULL);
            // Note: No need to rewrite file here unless content changes significantly.
             // File only stores the input value itself. Metadata could go in separate file?
        }
    } else {
        // --- Create New Corpus Entry ---
        CorpusEntry* new_corpus_entry = (CorpusEntry*)malloc(sizeof(CorpusEntry));
        if (!new_corpus_entry) {
            fprintf(stderr, "Failed to allocate memory for corpus entry\n");
            return -1;
        }

        new_corpus_entry->input_value = input_value;
        new_corpus_entry->fitness_score = fitness_score;
        new_corpus_entry->is_interesting = is_interesting;
        new_corpus_entry->timestamp = time(NULL);

        // Allocate and copy the coverage map for this entry
        new_corpus_entry->coverage_map = (coverage_t*)malloc(COVERAGE_MAP_SIZE * sizeof(coverage_t));
        if (!new_corpus_entry->coverage_map) {
            fprintf(stderr, "Failed to allocate memory for corpus entry coverage map\n");
            free(new_corpus_entry);
            return -1;
        }
        if (coverage_map) {
             memcpy(new_corpus_entry->coverage_map, coverage_map, COVERAGE_MAP_SIZE * sizeof(coverage_t));
        } else {
             // If no coverage provided (e.g., initial random inputs?), zero it out.
             memset(new_corpus_entry->coverage_map, 0, COVERAGE_MAP_SIZE * sizeof(coverage_t));
        }


        // Create hash table entry
        hash_entry = (CorpusHash*)malloc(sizeof(CorpusHash));
        if (!hash_entry) {
            fprintf(stderr, "Failed to allocate memory for corpus hash entry\n");
            free(new_corpus_entry->coverage_map);
            free(new_corpus_entry);
            return -1;
        }
        hash_entry->input_value = input_value;
        hash_entry->entry = new_corpus_entry;

        // Add to hash table
        HASH_ADD_INT(corpus_table, input_value, hash_entry);
        corpus_size++;

        // Save the input value itself to a file in the corpus directory
        char filename[PATH_MAX]; // Use PATH_MAX from limits.h
        // Use a more robust naming scheme, e.g., based on hash or timestamp+seq
        // For now, simple sequential or value-based name. Avoid value if too large.
        snprintf(filename, sizeof(filename), "%s/input_%d_%ld", corpus_directory, corpus_size, (long)time(NULL));
        // Alternative: snprintf(filename, sizeof(filename), "%s/input-%d", corpus_directory, input_value); // If input values are reasonable

        FILE* fp = fopen(filename, "w");
        if (fp) {
            fprintf(fp, "%d\n", input_value); // Save only the input value
            fclose(fp);
             // TODO: Save metadata (coverage hash, fitness) separately?
             // char meta_filename[PATH_MAX];
             // snprintf(meta_filename, sizeof(meta_filename), "%s.meta", filename);
             // FILE* meta_fp = fopen(meta_filename, "wb"); // Binary for coverage?
             // if (meta_fp) { /* write fitness, write coverage map */ fclose(meta_fp); }
        } else {
             fprintf(stderr, "Warning: Failed to save input file %s\n", filename);
             // Should we remove from memory if file save fails? Maybe not.
        }
    }

    return 0;
}

// Load corpus from directory (basic version - loads only inputs)
// TODO: Enhance to load coverage/fitness metadata if saved separately.
int loadCorpus(const char* corpus_dir) {
    DIR* dir;
    struct dirent* entry;
    char filepath[PATH_MAX];
    FILE* fp;
    int input_value;
    int loaded_count = 0;

    if (!corpus_dir || corpus_dir[0] == '\0') {
         if (corpus_directory[0] == '\0') {
              fprintf(stderr, "Error: Corpus directory not set for loading.\n");
              return -1;
         }
         corpus_dir = corpus_directory; // Use initialized directory if none provided
    } else {
        // Update the global directory path if a new one is provided
         strncpy(corpus_directory, corpus_dir, sizeof(corpus_directory) - 1);
         corpus_directory[sizeof(corpus_directory) - 1] = '\0';
    }


    dir = opendir(corpus_dir);
    if (!dir) {
        fprintf(stderr, "Warning: Failed to open corpus directory for loading: %s\n", corpus_dir);
        // Don't treat as fatal, maybe it's the first run.
        return 0;
    }

    printf("Loading corpus from: %s\n", corpus_dir);

    // Read each file in the directory
    while ((entry = readdir(dir)) != NULL) {
         // Basic check: starts with "input_" or similar convention used in saveToCorpus
        if (strncmp(entry->d_name, "input_", 6) == 0) {
            snprintf(filepath, sizeof(filepath), "%s/%s", corpus_dir, entry->d_name);

            // Check if it's a regular file before opening
             struct stat path_stat;
             if (stat(filepath, &path_stat) != 0 || !S_ISREG(path_stat.st_mode)) {
                  continue; // Skip directories, special files etc.
             }


            fp = fopen(filepath, "r");
            if (fp) {
                if (fscanf(fp, "%d", &input_value) == 1) {
                    // Found an input value. Add it to the in-memory corpus.
                    // We don't have coverage/fitness from file yet, so use defaults.
                    // The fuzzer should re-evaluate these inputs later if needed.
                    coverage_t* placeholder_map = calloc(COVERAGE_MAP_SIZE, sizeof(coverage_t));
                    if (placeholder_map) {
                        saveToCorpus(input_value, placeholder_map, 0.0, 0); // Add with 0 fitness/coverage
                        free(placeholder_map);
                        loaded_count++;
                    } else {
                         fprintf(stderr, "Warning: Failed to alloc placeholder map for loading %s\n", filepath);
                    }
                } else {
                     fprintf(stderr, "Warning: Failed to parse input value from corpus file %s\n", filepath);
                }
                fclose(fp);

                 // TODO: Load metadata if exists (e.g., filepath + ".meta")
                 // char meta_filepath[PATH_MAX];
                 // snprintf(meta_filepath, sizeof(meta_filepath), "%s.meta", filepath);
                 // Load fitness/coverage from meta_filepath and update the entry in corpus_table
            } else {
                 fprintf(stderr, "Warning: Failed to open corpus file %s\n", filepath);
            }
        }
    }

    closedir(dir);
    printf("Loaded %d entries from corpus directory.\n", loaded_count);
    return corpus_size; // Return total size after loading
}


// Minimize corpus based on coverage (simple N^2 approach)
// Assumes corpus entries have valid coverage maps loaded/evaluated.
int minimizeCorpus() {
    if (corpus_size <= 1) {
        return corpus_size; // Nothing to minimize
    }

    printf("Starting corpus minimization (initial size: %d)...\n", corpus_size);

    CorpusHash* current, *tmp;
    int removed_count = 0;
    int kept_count = 0;

    // Build a combined coverage map of all entries we decide to *keep*.
    coverage_t* combined_kept_coverage = calloc(COVERAGE_MAP_SIZE, sizeof(coverage_t));
    if (!combined_kept_coverage) {
         fprintf(stderr, "Error: Failed to allocate map for minimization.\n");
         return -1;
    }

    // Use a temporary hash table to store entries to keep.
    CorpusHash* kept_corpus_table = NULL;

    // Iterate through the current corpus. For each entry, check if it adds
    // coverage not already covered by the 'kept' set.
    // Process in some order? Maybe sort by fitness or size first? For now, hash order.
    HASH_ITER(hh, corpus_table, current, tmp) {
        int adds_new_coverage = 0;

        // Always keep entries marked as interesting (e.g., crashes)
        if (current->entry->is_interesting) {
            adds_new_coverage = 1;
        } else {
             // Check if this entry's map covers anything not in combined_kept_coverage
             if (current->entry->coverage_map) {
                  for (int i = 0; i < COVERAGE_MAP_SIZE; i++) {
                       if (current->entry->coverage_map[i] > 0 && combined_kept_coverage[i] == 0) {
                            adds_new_coverage = 1;
                            break;
                       }
                  }
             }
        }


        if (adds_new_coverage) {
            // Keep this entry. Add it to the temporary 'kept' table.
            // Add its coverage to the combined map.
            if (current->entry->coverage_map) {
                 for (int i = 0; i < COVERAGE_MAP_SIZE; i++) {
                      if (current->entry->coverage_map[i] > 0) {
                           combined_kept_coverage[i] = 1; // Mark as covered
                      }
                 }
            }

            // Add a *copy* to the kept table (or just transfer ownership carefully)
            // Simplest: Add pointer, will handle cleanup later.
             CorpusHash* kept_entry_hash = (CorpusHash*)malloc(sizeof(CorpusHash)); // Need new hash handle
             if (!kept_entry_hash) { /* error */ continue; }
             kept_entry_hash->input_value = current->input_value;
             kept_entry_hash->entry = current->entry; // Share the CorpusEntry pointer
             HASH_ADD_INT(kept_corpus_table, input_value, kept_entry_hash);
             kept_count++;

        } else {
            // This entry is redundant. Remove it from the original table and free resources.
            HASH_DEL(corpus_table, current);
            // Free only if not shared with kept_corpus_table!
            // In this simple transfer, we don't free here. Cleanup happens below.
            removed_count++;
        }
    }

    // Now, cleanup the *original* table. Entries pointed to by kept_corpus_table
    // should NOT have their CorpusEntry freed yet.
     HASH_ITER(hh, corpus_table, current, tmp) {
          // These are the entries that were NOT kept
           HASH_DEL(corpus_table, current);
           if (current->entry) {
                free(current->entry->coverage_map);
                free(current->entry);
           }
           free(current); // Free the hash struct itself
     }


    // Replace the global corpus table with the minimized one
    corpus_table = kept_corpus_table;
    corpus_size = kept_count;

    free(combined_kept_coverage);

    printf("Corpus minimized: Kept %d entries, removed %d redundant entries\n", kept_count, removed_count);
    return corpus_size;
}


// Select a corpus entry for mutation/fuzzing
CorpusEntry* selectCorpusEntry() {
    if (corpus_size == 0) {
        return NULL;
    }

    // --- Simple Strategy: Random Selection ---
    int index = rand() % corpus_size;
    CorpusHash* current = corpus_table; // Start at the beginning
    int i = 0;
    // Iterate through the hash table until the index-th element is reached
    // Note: Hash table iteration order is not guaranteed, but consistent per run usually.
    while (current != NULL && i < index) {
        current = current->hh.next;
        i++;
    }
    // If current is NULL here, something is wrong (index out of bounds?)
    return (current != NULL) ? current->entry : NULL;


    // --- TODO: Advanced Strategies ---
    // - Weighted selection based on fitness score
    // - Favor entries that haven't been fuzzed recently
    // - Favor smaller entries? (if size is tracked)
    // - Favor entries covering rarer paths?
}

// Cleanup corpus memory
void cleanupCorpus(void) {
    CorpusHash* current, *tmp;

    HASH_ITER(hh, corpus_table, current, tmp) {
        HASH_DEL(corpus_table, current);
        if (current->entry) {
             free(current->entry->coverage_map); // Free the associated map
             free(current->entry);              // Free the CorpusEntry struct
        }
        free(current); // Free the hash struct itself
    }

    corpus_table = NULL; // Ensure the global pointer is NULL
    corpus_size = 0;
    // corpus_directory remains set, not cleared here
}

// Get current corpus size
int getCorpusSize(void) {
    // Could use HASH_COUNT(corpus_table) but we maintain corpus_size anyway
    return corpus_size;
}

// Calculate average fitness score of entries in the corpus
double getAverageCorpusFitness(void) {
    if (corpus_size == 0) {
        return 0.0;
    }

    double total_fitness = 0.0;
    CorpusHash* current, *tmp;

    HASH_ITER(hh, corpus_table, current, tmp) {
         if (current->entry) {
              total_fitness += current->entry->fitness_score;
         }
    }

    return total_fitness / corpus_size;
}

// Print statistics about the current corpus
void printCorpusStats(void) {
    printf("--- Corpus Statistics ---\n");
    printf("  Total entries:     %d\n", corpus_size);
    printf("  Average fitness:   %.2f\n", getAverageCorpusFitness());

    // Count interesting entries (e.g., crashes, new coverage)
    int interesting_count = 0;
    CorpusHash* current, *tmp;
    HASH_ITER(hh, corpus_table, current, tmp) {
        if (current->entry && current->entry->is_interesting) {
            interesting_count++;
        }
    }
    printf("  Interesting entries: %d\n", interesting_count);
    printf("-------------------------\n");
}